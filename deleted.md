
## 具象型の詳細

アルゴリズム基本の話をするので

基本分かってるマンは寝ててください

### Order

処理に必要な時間が何に比例するか

- O(1): どんな処理でも一瞬
- O(n): 要素数に比例した時間(おそい)
- O(log n): まあまあはやい(nが1024で10ぐらい)

---

## 単方向リスト

- 次の要素への参照(ポインタ)
- 値

の2つを1要素として構成し、最後はNilで〆める

- 最初の要素の取得はO(1)
- ループは早い
- 要素数の取得はO(n)
- m番目の要素の取得はO(m)

あんまり早くない

---

### 単方向リストのウリ
最大のウリは、副作用・コピー無しで要素追加可能な点

一番最初に追加するとき、既存のListへの変更がない

```scala
val xs = 1 :: 2 :: 3 :: Nil // or List(1, 2, 3)
val ys = 0 :: xs
// ys = 0 :: 1 :: 2 :: 3 :: Nil
```

再帰的な構造になっている

---

## Tree
Nodeとそれに繋がる子要素を持つ

ListもTreeの1種と見做すことができる

プログラミングにおいて非常に一般的な構造である

- m番目の要素の取得はO(log m)

---

## Treeの各種実装
### 二分木
2の要素を持つ

シンプルだがランダムアクセスが多発する

### Btree
DBでよく使われる(HDDがランダムアクセスに弱いので

### Vector
32の要素を持つ

要素数が1024までは1回の間接参照でアクセス

各要素は事実上O(1)

たぶんBtree

---

## Array
- RubyのArrayと同一
- 連続したメモリ領域を取得

- 添字アクセスがO(1)
- 要素数の増減に弱い
- 連続したメモリ領域が必要

ScalaのArrayはJavaプリミティブ

ArrayBufferが薄いラッパー

---

## HashTable
RubyではHashと呼ばれているもの

### Hash関数
ある値を関係ない、ランダムな値にする

同じ値は常に同じHash値になればよい

できるだけ重複しないのが良いHash関数

---

### Table
Hashの長さだけのArrayを用意して要素を格納

- 任意の型のKeyが持てる
- Keyの探索はO(1)
- 順序は保存できない
- メモリ効率は悪い
